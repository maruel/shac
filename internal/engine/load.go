// Copyright 2023 The Shac Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package engine

//go:generate go install google.golang.org/protobuf/cmd/protoc-gen-go@v1.30.0
//go:generate protoc --go_out=. --go_opt=paths=source_relative shac.proto

import (
	"context"
	"errors"
	"fmt"
	"path/filepath"
	"runtime"
	"strings"
	"sync"

	"go.chromium.org/luci/starlark/builtins"
	"go.chromium.org/luci/starlark/interpreter"
	"go.starlark.net/resolve"
	"go.starlark.net/starlark"
	"golang.org/x/sync/errgroup"
)

func init() {
	// Enable not-yet-standard Starlark features.
	resolve.AllowRecursion = true
	resolve.AllowSet = true
}

// Report exposes callbacks that the engine calls for everything generated by
// the starlark code.
type Report interface {
	// Print is called when print() starlark function is called.
	//
	// Guaranteed to be serialized.
	Print(ctx context.Context, file string, line int, message string)
}

// Load loads a main shac.star file from a root directory.
//
// main is normally ctx.star.
func Load(ctx context.Context, root, main string, allFiles bool, r Report) error {
	if filepath.IsAbs(main) {
		return errors.New("main file must not be an absolute path")
	}
	var err error
	if root, err = filepath.Abs(root); err != nil {
		return err
	}
	s, err := parse(ctx, &inputs{
		code:     interpreter.FileSystemLoader(root),
		root:     root,
		main:     main,
		allFiles: allFiles,
	}, r)
	if err != nil {
		return err
	}
	if len(s.checks.c) == 0 && !s.printCalled {
		return errors.New("did you forget to call shac.register_check?")
	}
	ctx = context.WithValue(ctx, &stateCtxKey, s)
	if err := s.checks.callAll(ctx, s.intr); err != nil {
		return err
	}
	return nil
}

// inputs represents a starlark package.
type inputs struct {
	code     interpreter.Loader
	root     string
	main     string
	allFiles bool
}

// state represents a parsing state of the main starlark tree.
type state struct {
	intr   *interpreter.Interpreter
	inputs *inputs
	scm    scmCheckout

	checks      checks
	doneLoading bool

	mu          sync.Mutex
	printCalled bool
}

// ctxState pulls out *state from the context.
//
// Panics if not there.
func ctxState(ctx context.Context) *state {
	return ctx.Value(&stateCtxKey).(*state)
}

var stateCtxKey = "shac.State"

var (
	// version is the current tool version.
	//
	// TODO(maruel): Add proper version, preferably from git tag.
	version = [...]int{0, 0, 1}
)

func parse(ctx context.Context, inputs *inputs, r Report) (*state, error) {
	failures := builtins.FailureCollector{}
	s := &state{
		inputs: inputs,
	}
	s.intr = &interpreter.Interpreter{
		Predeclared: getPredeclared(),
		Packages: map[string]interpreter.Loader{
			interpreter.MainPkg: inputs.code,
		},
		Logger: func(file string, line int, message string) {
			s.mu.Lock()
			defer s.mu.Unlock()
			s.printCalled = true
			r.Print(ctx, file, line, message)
		},
		ThreadModifier: func(th *starlark.Thread) {
			failures.Install(th)
		},
	}
	ctx = context.WithValue(ctx, &stateCtxKey, s)

	s.scm = getSCM(ctx, inputs.root)

	var err error
	if err = s.intr.Init(ctx); err == nil {
		_, err = s.intr.ExecModule(ctx, interpreter.MainPkg, s.inputs.main)
	}
	if err != nil {
		if f := failures.LatestFailure(); f != nil {
			// Prefer the collected error if any, it will have a collected trace.
			err = f
		}
		return nil, err
	}
	// TODO(maruel): Error if there are unconsumed variables once variables are
	// added.
	s.doneLoading = true
	return s, nil
}

// checks is a list of registered checks callbacks.
//
// It lives in state. Checks are executed sequentially after all Starlark
// code is loaded. They run checks and emit results (results and comments).
type checks struct {
	c []check
}

type check struct {
	cb starlark.Callable
}

// add registers a new callback.
func (c *checks) add(cb starlark.Callable) error {
	c.c = append(c.c, check{cb: cb})
	return nil
}

func (c *check) name() string {
	return strings.TrimPrefix(c.cb.Name(), "_")
}

// callAll calls all the checks.
//
// It creates a separate thread per check, limited by the number of CPU cores +
// 2. This permits to run them concurrently.
func (c *checks) callAll(ctx context.Context, intr *interpreter.Interpreter) error {
	eg, ctx := errgroup.WithContext(ctx)
	eg.SetLimit(runtime.NumCPU() + 2)
	for i := range c.c {
		i := i
		eg.Go(func() error {
			n := c.c[i].name()
			th := intr.Thread(ctx)
			th.Name = n
			fc := builtins.GetFailureCollector(th)
			if fc != nil {
				fc.Clear()
			}
			// TODO(maruel): Set a context for the subdirectory.
			args := starlark.Tuple{getCtx()}
			args.Freeze()
			if r, err := starlark.Call(th, c.c[i].cb, args, nil); err != nil {
				if fc != nil && fc.LatestFailure() != nil {
					// Prefer this error, it has custom stack trace.
					return fc.LatestFailure()
				}
				return err
			} else if r != starlark.None {
				return fmt.Errorf("check %q returned an object of type %s, expected None", n, r.Type())
			}
			return nil
		})
	}
	return eg.Wait()
}
