// Copyright 2023 The Shac Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package engine

//go:generate go install google.golang.org/protobuf/cmd/protoc-gen-go@v1.30.0
//go:generate protoc --go_out=. --go_opt=paths=source_relative shac.proto

import (
	"context"
	"errors"
	"fmt"
	"path/filepath"
	"runtime"
	"sync"

	"go.chromium.org/luci/starlark/interpreter"
	"go.starlark.net/resolve"
	"go.starlark.net/starlark"
	"golang.org/x/sync/errgroup"
)

func init() {
	// Enable not-yet-standard Starlark features.
	resolve.AllowRecursion = true
	resolve.AllowSet = true
}

// Cursor represents a point in a content; generally a source file but it can
// also be a change description.
type Cursor struct {
	Line int
	Col  int

	// Require keyed arguments.
	_ struct{}
}

// Span represents a section in a source file or a change description.
type Span struct {
	Start Cursor
	End   Cursor

	// Require keyed arguments.
	_ struct{}
}

// Level is one of "notice", "warning" or "error".
//
// A check is only considered failed if it emits at least one annotation with
// level "error".
type Level string

// Valid Level values.
const (
	Notice  Level = "notice"
	Warning Level = "warning"
	Error   Level = "error"
)

func (l Level) isValid() bool {
	switch l {
	case Notice, Warning, Error:
		return true
	default:
		return false
	}
}

// Report exposes callbacks that the engine calls for everything generated by
// the starlark code.
type Report interface {
	// EmitAnnotation emits an annotation by a check for a specific file. This is
	// not a failure by itself, unless level "error" is used.
	EmitAnnotation(ctx context.Context, check string, level Level, message, file string, s Span, replacements []string) error
	// EmitArtifact emits an artifact by a check.
	EmitArtifact(ctx context.Context, check, file string, content []byte) error
	// Print is called when print() starlark function is called.
	Print(ctx context.Context, file string, line int, message string)
}

// Run loads a main shac.star file from a root directory and runs it.
func Run(ctx context.Context, root, main string, allFiles bool, r Report) error {
	if filepath.IsAbs(main) {
		return errors.New("main file must not be an absolute path")
	}
	var err error
	if root, err = filepath.Abs(root); err != nil {
		return err
	}
	s := &state{
		inputs: &inputs{
			code:     interpreter.FileSystemLoader(root),
			root:     root,
			main:     main,
			allFiles: allFiles,
		},
		r: r,
	}
	s.scm, err = getSCM(ctx, root)
	if err != nil {
		return err
	}
	// Parse the starlark file.
	ctx = context.WithValue(ctx, &stateCtxKey, s)
	if err := s.parse(ctx); err != nil {
		return err
	}
	if len(s.checks) == 0 && !s.printCalled {
		return errors.New("did you forget to call shac.register_check?")
	}
	// Last phase where checks are called.
	if err := s.callAllChecks(ctx); err != nil {
		return err
	}
	// If any check failed, return an error.
	for i := range s.checks {
		if s.checks[i].hadError {
			return ErrCheckFailed
		}
	}
	return nil
}

// inputs represents a starlark package.
type inputs struct {
	code     interpreter.Loader
	root     string
	main     string
	allFiles bool
}

// state represents the parsing and running state of an execution tree.
type state struct {
	inputs *inputs
	r      Report
	scm    scmCheckout

	// TODO(maruel): There will be one shacState per shac.star found in
	// subdirectories.
	shacState
}

// ctxState pulls out *state from the context.
//
// Panics if not there.
func ctxState(ctx context.Context) *state {
	return ctx.Value(&stateCtxKey).(*state)
}

var stateCtxKey = "shac.state"

// parse parses a single shac.star file.
//
// TODO(maruel): Returns one new shacState for the input.
func (s *state) parse(ctx context.Context) error {
	s.intr = &interpreter.Interpreter{
		Predeclared: getPredeclared(),
		Packages: map[string]interpreter.Loader{
			interpreter.MainPkg: s.inputs.code,
		},
		Logger: func(file string, line int, message string) {
			s.mu.Lock()
			s.printCalled = true
			s.mu.Unlock()
			s.r.Print(ctx, file, line, message)
		},
	}

	var err error
	if err = s.intr.Init(ctx); err == nil {
		_, err = s.intr.ExecModule(ctx, interpreter.MainPkg, s.inputs.main)
	}
	if err != nil {
		if s.failErr != nil {
			// We got a fail() call, use this instead.
			return s.failErr
		}
		var evalErr *starlark.EvalError
		if errors.As(err, &evalErr) {
			return &evalError{evalErr}
		}
		return err
	}
	s.doneLoading = true
	return nil
}

// shacState represents a parsing state of one shac.star.
type shacState struct {
	intr *interpreter.Interpreter
	// checks is the list of registered checks callbacks via shac.register_check().
	//
	// Checks are added serially, so no lock is needed.
	//
	// Checks are executed sequentially after all Starlark code is loaded and not
	// mutated. They run checks and emit results (results and comments).
	checks []check

	// Set when fail() is called. This happens only during the first phase, thus
	// no mutex is needed.
	failErr *failure

	// Set when the first phase of starlark interpretation is complete. This
	// complete the serial part, after which execution becomes concurrent.
	doneLoading bool

	mu          sync.Mutex
	printCalled bool
}

// callAllChecks calls all the checks.
//
// It creates a separate thread per check, limited by the number of CPU cores +
// 2. This permits to run them concurrently.
func (s *shacState) callAllChecks(ctx context.Context) error {
	eg, ctx := errgroup.WithContext(ctx)
	eg.SetLimit(runtime.NumCPU() + 2)
	for i := range s.checks {
		i := i
		eg.Go(func() error {
			return s.checks[i].call(ctx, s.intr)
		})
	}
	return eg.Wait()
}

// check represents one check added via shac.register_check().
type check struct {
	cb       starlark.Callable
	name     string
	failErr  *failure // set when fail() is called from within the check, an abnormal failure.
	hadError bool     // set when an error is emitted via Report, a normal error.
}

var checkCtxKey = "shac.check"

// ctxCheck pulls out *check from the context.
//
// Returns nil when not run inside a check.
func ctxCheck(ctx context.Context) *check {
	c, _ := ctx.Value(&checkCtxKey).(*check)
	return c
}

// call calls the check callback and returns an error if an abnormal error happened.
//
// A "normal" error will still have this function return nil.
func (c *check) call(ctx context.Context, intr *interpreter.Interpreter) error {
	ctx = context.WithValue(ctx, &checkCtxKey, c)
	th := intr.Thread(ctx)
	th.Name = c.name
	args := starlark.Tuple{getCtx()}
	args.Freeze()
	if r, err := starlark.Call(th, c.cb, args, nil); err != nil {
		if c.failErr != nil {
			// fail() was called, return this error since this is an abnormal failure.
			return c.failErr
		}
		var evalErr *starlark.EvalError
		if errors.As(err, &evalErr) {
			return &evalError{evalErr}
		}
	} else if r != starlark.None {
		return fmt.Errorf("check %q returned an object of type %s, expected None", c.name, r.Type())
	}
	return nil
}
